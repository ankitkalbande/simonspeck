// Package simon implements the Simon family of NSA block ciphers. It
// is a straightforward translation of the pseudocode in the paper [1]
// into golang. This implementation is not cryptographically secure.
// This code correctly encodes the supplied test vectors in [1] with
// the following conventions: words are stored with a little-endian
// representation, and the test vectors are reversed (i.e., the
// plaintext "6565 6877" for Simon32/64 is stored as []byte{0x77,
// 0x68, 0x65, 0x65}.
//
// [1]: http://eprint.iacr.org/2013/404
package simon

const (
	roundsSimon96_96  = 52
	roundsSimon96_144 = 54

	zSeq0 = 0xd9c3522fb386a45f
	zSeq1 = 0x56864fb8ad0c9f71
	zSeq2 = 0x7369f885192c0ef5
	zSeq3 = 0xfc2ce51207a635db
	zSeq4 = 0xfdc94c3a046d678b
)

// Simon relies on five bit sequences generated by LFSRs. For fun
// I've implemented each as a shift register rather than bit constants.
// ShiftU corresponds to the matrix
// [0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 1 0 0 0 1].
func ShiftU(reg uint) uint {
	s := reg << 1
	if s&32 != 0 {
		s ^= 37
	}
	s ^= reg & 1
	return s
}

// ShiftV corresponds to the matrix
// [0 1 1 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 1 0 0 0 0].
func ShiftV(reg uint) uint {
	s := reg << 1
	if s&32 != 0 {
		s ^= 37
	}
	s ^= (reg & 4) << 2
	return s
}

// ShiftW corresponds to the matrix
// [0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 1 0 0 0 0].
func ShiftW(reg uint) uint {
	s := reg << 1
	if s&32 != 0 {
		s ^= 37
	}
	return s
}
