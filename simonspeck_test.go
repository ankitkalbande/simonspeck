package simonspeck

import (
	"crypto/cipher"
	"math/rand"
	"testing"
)

func TestRotate(t *testing.T) {
	if leftRotate16(0x0003, 15) != 0x8001 {
		t.Errorf("Bad 16-bit rotation")
	}
	if leftRotate24(0x00a0f12f, 3) != 0x007897d {
		t.Errorf("Bad 24-bit rotation")
	}
}

type testLFSRVector struct {
	name         string
	binaryOutput string
	lfsr         func(uint) uint
}

var testLFSRVectors = []testLFSRVector{
	testLFSRVector{
		"ShiftU",
		"11111010001001010110000111001101111101000100101011000011100110",
		ShiftU,
	},
	testLFSRVector{
		"ShiftV",
		"10001110111110010011000010110101000111011111001001100001011010",
		ShiftV,
	},
	testLFSRVector{
		"ShiftW",
		"10000100101100111110001101110101000010010110011111000110111010",
		ShiftW,
	},
}

func TestShift(t *testing.T) {
	for _, testVec := range testLFSRVectors {
		reg := uint(1)
		for i, c := range testVec.binaryOutput {
			if reg&1 == 1 && c == '0' || reg&1 == 0 && c == '1' {
				t.Errorf("Bad output at bit %d of LFSR %s\n", i, testVec.name)
				break
			}
			reg = testVec.lfsr(reg)
		}
	}
}

type testVector struct {
	name       string
	cipher     cipher.Block
	plaintext  []byte
	ciphertext []byte
}

// The endianness of these test vectors is a bit of a mess in the
// paper. The plaintext/ciphertext pairs are given in words; my code
// is little-endian, so the orders of the bytes in words are reversed.
// Note that the key is given "in reverse" in the pseudocode.
var testVectors = []testVector{
	testVector{
		"Simon32/64",
		NewSimon32([]byte{0x00, 0x01, 0x08, 0x09, 0x10, 0x11, 0x18, 0x19}),
		[]byte{0x77, 0x68, 0x65, 0x65},
		[]byte{0xbb, 0xe9, 0x9b, 0xc6},
	},
	testVector{
		"Simon48/72",
		NewSimon48([]byte{
			0x00, 0x01, 0x02,
			0x08, 0x09, 0x0a,
			0x10, 0x11, 0x12,
		}),
		[]byte{0x6c, 0x69, 0x6e, 0x67, 0x20, 0x61},
		[]byte{0xac, 0x2c, 0x29, 0xac, 0xe5, 0xda},
	},
	testVector{
		"Simon48/96",
		NewSimon48([]byte{
			0x00, 0x01, 0x02,
			0x08, 0x09, 0x0a,
			0x10, 0x11, 0x12,
			0x18, 0x19, 0x1a,
		}),
		[]byte{0x6e, 0x64, 0x20, 0x63, 0x69, 0x72},
		[]byte{0x56, 0xf1, 0xac, 0xa5, 0x06, 0x6e},
	},
	testVector{
		"Simon64/96",
		NewSimon64([]byte{
			0x00, 0x01, 0x02, 0x03,
			0x08, 0x09, 0x0a, 0x0b,
			0x10, 0x11, 0x12, 0x13,
		}),
		[]byte{0x63, 0x6c, 0x69, 0x6e, 0x67, 0x20, 0x72, 0x6f},
		[]byte{0xc8, 0x8f, 0x1a, 0x11, 0x7f, 0xe2, 0xa2, 0x5c},
	},
	testVector{
		"Simon64/128",
		NewSimon64([]byte{
			0x00, 0x01, 0x02, 0x03,
			0x08, 0x09, 0x0a, 0x0b,
			0x10, 0x11, 0x12, 0x13,
			0x18, 0x19, 0x1a, 0x1b,
		}),
		[]byte{0x75, 0x6e, 0x64, 0x20, 0x6c, 0x69, 0x6b, 0x65},
		[]byte{0x7a, 0xa0, 0xdf, 0xb9, 0x20, 0xfc, 0xc8, 0x44},
	},
	testVector{
		"Simon96/96",
		NewSimon96([]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
		}),
		[]byte{
			0x20, 0x74, 0x68, 0x65, 0x20, 0x70,
			0x69, 0x6c, 0x6c, 0x61, 0x72, 0x20,
		},
		[]byte{
			0x82, 0xf0, 0x8f, 0x3d, 0x06, 0x69,
			0xb4, 0x62, 0xa4, 0x07, 0x28, 0x60,
		},
	},
	testVector{
		"Simon96/128",
		NewSimon96([]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
		}),
		[]byte{
			0x6f, 0x66, 0x20, 0x64, 0x75, 0x73,
			0x74, 0x20, 0x74, 0x68, 0x61, 0x74,
		},
		[]byte{
			0xe9, 0x1a, 0xdb, 0xc5, 0x59, 0x3f,
			0x1e, 0x45, 0x6c, 0x1c, 0xad, 0xec,
		},
	},
	testVector{
		"Simon128/128",
		NewSimon128([]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
		}),
		[]byte{
			0x20, 0x74, 0x72, 0x61, 0x76, 0x65, 0x6c, 0x6c,
			0x65, 0x72, 0x73, 0x20, 0x64, 0x65, 0x73, 0x63,
		},
		[]byte{
			0xbc, 0x0b, 0x4e, 0xf8, 0x2a, 0x83, 0xaa, 0x65,
			0x3f, 0xfe, 0x54, 0x1e, 0x1e, 0x1b, 0x68, 0x49,
		},
	},
	testVector{
		"Simon128/192",
		NewSimon128([]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		}),
		[]byte{
			0x72, 0x69, 0x62, 0x65, 0x20, 0x77, 0x68, 0x65,
			0x6e, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20,
		},
		[]byte{
			0x5b, 0xb8, 0x97, 0x25, 0x6e, 0x8d, 0x9c, 0x6c,
			0x4f, 0x0d, 0xdc, 0xfc, 0xef, 0x61, 0xac, 0xc4,
		},
	},
	testVector{
		"Simon128/256",
		NewSimon128([]byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
		}),
		[]byte{
			0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x69, 0x6d,
			0x6f, 0x6f, 0x6d, 0x20, 0x69, 0x6e, 0x20, 0x74,
		},
		[]byte{
			0x68, 0xb8, 0xe7, 0xef, 0x87, 0x2a, 0xf7, 0x3b,
			0xa0, 0xa3, 0xc8, 0xaf, 0x79, 0x55, 0x2b, 0x8d,
		},
	},
	testVector{
		"Speck64/96",
		NewSpeck64([]byte{
			0x00, 0x01, 0x02, 0x03,
			0x08, 0x09, 0x0a, 0x0b,
			0x10, 0x11, 0x12, 0x13,
		}),
		[]byte{
			0x65, 0x61, 0x6e, 0x73,
			0x20, 0x46, 0x61, 0x74,
		},
		[]byte{
			0x6c, 0x94, 0x75, 0x41,
			0xec, 0x52, 0x79, 0x9f,
		},
	},
	testVector{
		"Speck64/128",
		NewSpeck64([]byte{
			0x00, 0x01, 0x02, 0x03,
			0x08, 0x09, 0x0a, 0x0b,
			0x10, 0x11, 0x12, 0x13,
			0x18, 0x19, 0x1a, 0x1b,
		}),
		[]byte{
			0x2d, 0x43, 0x75, 0x74,
			0x74, 0x65, 0x72, 0x3b,
		},
		[]byte{
			0x8b, 0x02, 0x4e, 0x45,
			0x48, 0xa5, 0x6f, 0x8c,
		},
	},
}

func TestSuppliedVectors(t *testing.T) {
	for _, testVec := range testVectors {
		output := make([]byte, len(testVec.ciphertext))
		testVec.cipher.Encrypt(output, testVec.plaintext)
		t.Logf("cipher: %s\tplaintext: %s\n", testVec.name, string(testVec.plaintext))
		for i, c := range testVec.ciphertext {
			if c != output[i] {
				t.Errorf("Bad encryption for %s; expecting 0x%02x, got 0x%02x", testVec.name, c, output[i])
			}
		}
	}
}

func randomSlice(length int) []byte {
	s := make([]byte, length)
	for i, _ := range s {
		s[i] = byte(rand.Int())
	}
	return s
}

func TestEncDec32(t *testing.T) {
	var names = []string{
		"Simon32/64",
		"Simon48/72",
		"Simon48/96",
		"Simon64/96",
		"Simon64/128",
		"Simon96/96",
		"Simon96/144",
		"Simon128/128",
		"Simon128/192",
		"Simon128/256",
		"Speck64/96",
		"Speck64/128",
	}
	var ciphers = []cipher.Block{
		NewSimon32(randomSlice(8)),
		NewSimon48(randomSlice(9)),
		NewSimon48(randomSlice(12)),
		NewSimon64(randomSlice(12)),
		NewSimon64(randomSlice(16)),
		NewSimon96(randomSlice(12)),
		NewSimon96(randomSlice(18)),
		NewSimon128(randomSlice(16)),
		NewSimon128(randomSlice(24)),
		NewSimon128(randomSlice(32)),
		NewSpeck64(randomSlice(12)),
		NewSpeck64(randomSlice(16)),
	}

	for j, c := range ciphers {
		iv := randomSlice(c.BlockSize())
		// We use CBC as it uses both encryption and decryption.
		enc := cipher.NewCBCEncrypter(c, iv)
		dec := cipher.NewCBCDecrypter(c, iv)
		plaintext := randomSlice(16384 * c.BlockSize())
		ciphertext := make([]byte, 16384*c.BlockSize())
		enc.CryptBlocks(ciphertext, plaintext)
		dec.CryptBlocks(ciphertext, ciphertext)
		for i, p := range plaintext {
			if p != ciphertext[i] {
				t.Errorf("Encryption followed by decryption failed for %s.", names[j])
				break
			}
		}
	}
}
