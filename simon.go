// Package simon implements the Simon family of NSA block ciphers.
// For now, I only plan to implement Simon32, Simon64, and Simon128.
// This implementation is not cryptographically secure.
// See http://eprint.iacr.org/2013/404
package simon

func leftRotate16(n uint16, shift uint) uint16 {
	return (n << shift) | (n >> (16 - shift))
}

// Simon relies on five bit sequences generated by LFSRs. For fun
// I've implemented each as a shift register rather than bit constants.
// ShiftU corresponds to the matrix
// [0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 1 0 0 0 1].
func ShiftU(reg uint) uint {
	s := reg << 1
	if s&32 != 0 {
		s ^= 37
	}
	s ^= reg & 1
	return s
}

// ShiftV corresponds to the matrix
// [0 1 1 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 1 0 0 0 0].
func ShiftV(reg uint) uint {
	s := reg << 1
	if s&32 != 0 {
		s ^= 37
	}
	s ^= (reg & 4) << 2
	return s
}

// ShiftW corresponds to the matrix
// [0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 1 0 0 0 0].
func ShiftW(reg uint) uint {
	s := reg << 1
	if s&32 != 0 {
		s ^= 37
	}
	return s
}

// Use NewSimon32 below to expand a Simon32 key.
type Simon32Cipher struct {
	k      [32]uint16
	rounds int
}

// NewSimon32 creates and returns a new Simon32Cipher, which implements cipher.Block.
func NewSimon32(key uint64) *Simon32Cipher {
	cipher := new(Simon32Cipher)
	cipher.rounds = 32

	cipher.k[0] = uint16(key)
	cipher.k[1] = uint16(key >> 16)
	cipher.k[2] = uint16(key >> 32)
	cipher.k[3] = uint16(key >> 48)
	for i, reg := 4, uint(1); i < cipher.rounds; i++ {
		tmp := leftRotate16(cipher.k[i-1], 13)
		tmp ^= cipher.k[i-3]
		tmp ^= leftRotate16(tmp, 15)
		cipher.k[i] = ^cipher.k[i-4] ^ tmp ^ uint16(reg&1) ^ 3
		reg = ShiftU(reg)
	}
	return cipher
}

// Simon32 has a 32-bit block length. Note that this is in bytes, not words.
func (cipher *Simon32Cipher) BlockSize() int {
	return 4
}

// Feistel32 implements one round of Simon32 encryption.
func Feistel32(key, x, y uint16) (uint16, uint16) {
	fx := (leftRotate16(x, 1) & leftRotate16(x, 8)) ^ leftRotate16(x, 2)
	return y ^ fx ^ key, x
}

// DeFeistel32 implements one round of Simon32 decryption.
func DeFeistel32(key, x, y uint16) (uint16, uint16) {
	fy := (leftRotate16(y, 1) & leftRotate16(y, 8)) ^ leftRotate16(y, 2)
	return y, x ^ fy ^ key
}

// Encrypt encrypts the first block in src into dst.
// Dst and src may point at the same memory. See crypto/cipher.
func (cipher *Simon32Cipher) Encrypt(dst, src []byte) {
	if len(src) < 4 || len(dst) < 4 {
		panic("Simon32Cipher.Encrypt() requires at least one block to encipher.")
	}
	x := uint16(src[0]) | (uint16(src[1]) << 8)
	y := uint16(src[2]) | (uint16(src[3]) << 8)
	for i := 0; i < cipher.rounds; i++ {
		x, y = Feistel32(cipher.k[i], x, y)
	}
	dst[0] = byte(x)
	dst[1] = byte(x >> 8)
	dst[2] = byte(y)
	dst[3] = byte(y >> 8)
}

// Decrypt decrypts the first block in src into dst.
// Dst and src may point at the same memory. See crypto/cipher.
func (cipher *Simon32Cipher) Decrypt(dst, src []byte) {
	if len(src) < 4 || len(dst) < 4 {
		panic("Simon32Cipher.Encrypt() requires at least one block to decipher.")
	}
	x := uint16(src[0]) | (uint16(src[1]) << 8)
	y := uint16(src[2]) | (uint16(src[3]) << 8)
	for i := cipher.rounds - 1; i >= 0; i-- {
		x, y = DeFeistel32(cipher.k[i], x, y)
	}
	dst[0] = byte(x)
	dst[1] = byte(x >> 8)
	dst[2] = byte(y)
	dst[3] = byte(y >> 8)
}
