// Package simon implements the Simon family of NSA block ciphers.
// It is a straightforward translation of the pseudocode in the paper [1] into golang.
// This implementation is not cryptographically secure.
//
// [1]: http://eprint.iacr.org/2013/404
package simon

const (
	roundsSimon32_64   = 32
	roundsSimon48_72   = 36
	roundsSimon48_96   = 36
	roundsSimon64_96   = 42
	roundsSimon64_128  = 44
	roundsSimon96_96   = 52
	roundsSimon96_144  = 54
	roundsSimon128_128 = 68
	roundsSimon128_192 = 69
	roundsSimon128_256 = 72

	zSeq0 = 0xd9c3522fb386a45f
	zSeq1 = 0x56864fb8ad0c9f71
	zSeq2 = 0x7369f885192c0ef5
	zSeq3 = 0xfc2ce51207a635db
	zSeq4 = 0xfdc94c3a046d678b
)

func leftRotate16(n uint16, shift uint) uint16 {
	return (n << shift) | (n >> (16 - shift))
}

func leftRotate32(n uint32, shift uint) uint32 {
	return (n << shift) | (n >> (32 - shift))
}

func leftRotate64(n uint64, shift uint) uint64 {
	return (n << shift) | (n >> (64 - shift))
}

// Simon relies on five bit sequences generated by LFSRs. For fun
// I've implemented each as a shift register rather than bit constants.
// ShiftU corresponds to the matrix
// [0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 1 0 0 0 1].
func ShiftU(reg uint) uint {
	s := reg << 1
	if s&32 != 0 {
		s ^= 37
	}
	s ^= reg & 1
	return s
}

// ShiftV corresponds to the matrix
// [0 1 1 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 1 0 0 0 0].
func ShiftV(reg uint) uint {
	s := reg << 1
	if s&32 != 0 {
		s ^= 37
	}
	s ^= (reg & 4) << 2
	return s
}

// ShiftW corresponds to the matrix
// [0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 1 0 0 0 0].
func ShiftW(reg uint) uint {
	s := reg << 1
	if s&32 != 0 {
		s ^= 37
	}
	return s
}

// Use NewSimon32 below to expand a Simon32 key. Simon32Cipher
// implements the cipher.Block interface.
type Simon32Cipher struct {
	k [32]uint16
}

// NewSimon32 creates and returns a new Simon32Cipher. To compare with
// the test vectors in the NSA paper, give the key words in the same
// order as they appear in the paper, but as little-endian words. For
// example, the cipher with key "1918 1110 0908 0100" is generated by
// NewSimon32([]byte{0x18, 0x19, 0x10, 0x11, 0x08, 0x09, 0x00, 0x01}).
func NewSimon32(key []byte) *Simon32Cipher {
	cipher := new(Simon32Cipher)

	if len(key) != 8 {
		panic("NewSimon32 requires an 8-byte key")
	}
	for i := 0; i < 4; i++ {
		cipher.k[3-i] = uint16(key[2*i]) | (uint16(key[2*i+1]) << 8)
	}
	for i, reg := 4, uint(1); i < roundsSimon32_64; i++ {
		tmp := leftRotate16(cipher.k[i-1], 13)
		tmp ^= cipher.k[i-3]
		tmp ^= leftRotate16(tmp, 15)
		cipher.k[i] = ^cipher.k[i-4] ^ tmp ^ uint16(reg&1) ^ 3
		reg = ShiftU(reg)
	}
	return cipher
}

// Simon32 has a 32-bit block length. Note that this is in bytes, not words.
func (cipher *Simon32Cipher) BlockSize() int {
	return 4
}

// simonScramble16 is the only non-affine component of the Simon block cipher.
func simonScramble16(x uint16) uint16 {
	return (leftRotate16(x, 1) & leftRotate16(x, 8)) ^ leftRotate16(x, 2)
}

// Encrypt encrypts the first block in src into dst.
// Dst and src may point at the same memory. See crypto/cipher.
func (cipher *Simon32Cipher) Encrypt(dst, src []byte) {
	if len(src) < 4 || len(dst) < 4 {
		panic("Simon32Cipher.Encrypt() requires at least one block to encipher.")
	}
	x := uint16(src[0]) | (uint16(src[1]) << 8)
	y := uint16(src[2]) | (uint16(src[3]) << 8)
	for i := 0; i < roundsSimon32_64; i += 2 {
		y ^= simonScramble16(x) ^ cipher.k[i]
		x ^= simonScramble16(y) ^ cipher.k[i+1]
	}
	dst[0] = byte(x)
	dst[1] = byte(x >> 8)
	dst[2] = byte(y)
	dst[3] = byte(y >> 8)
}

// Decrypt decrypts the first block in src into dst.
// Dst and src may point at the same memory. See crypto/cipher.
func (cipher *Simon32Cipher) Decrypt(dst, src []byte) {
	if len(src) < 4 || len(dst) < 4 {
		panic("Simon32Cipher.Encrypt() requires at least one block to decipher.")
	}
	x := uint16(src[0]) | (uint16(src[1]) << 8)
	y := uint16(src[2]) | (uint16(src[3]) << 8)
	for i := roundsSimon32_64 - 1; i >= 0; i -= 2 {
		x ^= simonScramble16(y) ^ cipher.k[i]
		y ^= simonScramble16(x) ^ cipher.k[i-1]
	}
	dst[0] = byte(x)
	dst[1] = byte(x >> 8)
	dst[2] = byte(y)
	dst[3] = byte(y >> 8)
}

// Use NewSimon64 below to expand a Simon64 key. Simon64Cipher
// implements the cipher.Block interface.
type Simon64Cipher struct {
	k      []uint32
	rounds int // 42 for 96-bit key, 44 for 128-bit
}

func littleEndianBytesToUInt32(b []byte) uint32 {
	return uint32(b[0]) | (uint32(b[1]) << 8) | (uint32(b[2]) << 16) | (uint32(b[3]) << 24)
}

func storeLittleEndianUInt32(dst []byte, n uint32) {
	dst[0] = byte(n)
	dst[1] = byte(n >> 8)
	dst[2] = byte(n >> 16)
	dst[3] = byte(n >> 24)
}

// NewSimon64 creates and returns a new Simon64Cipher. It accepts
// either a 96-bit key (for Simon64/96) or a 128-bit key (for
// Simon64/128). See the documentation on Simon32 or the test suite
// for our endianness convention.
func NewSimon64(key []byte) *Simon64Cipher {
	cipher := new(Simon64Cipher)
	var keyWords int
	var z uint64

	switch len(key) {
	case 12:
		keyWords = 3
		z = zSeq2
		cipher.rounds = roundsSimon64_96
	case 16:
		keyWords = 4
		z = zSeq3
		cipher.rounds = roundsSimon64_128
	default:
		panic("NewSimon64() requires either a 96- or 128-bit key")
	}
	cipher.k = make([]uint32, cipher.rounds)
	for i := 0; i < keyWords; i++ {
		cipher.k[keyWords-i-1] = littleEndianBytesToUInt32(key[4*i : 4*i+4])
	}
	for i := keyWords; i < cipher.rounds; i++ {
		tmp := leftRotate32(cipher.k[i-1], 29)
		if keyWords == 4 {
			tmp ^= cipher.k[i-3]
		}
		tmp ^= leftRotate32(tmp, 31)
		lfsrBit := (z >> uint((i-keyWords)%62)) & 1
		cipher.k[i] = ^cipher.k[i-keyWords] ^ tmp ^ uint32(lfsrBit) ^ 3
	}
	return cipher
}

// Simon64 has a 64-bit block length. Note that this is in bytes, not words.
func (cipher *Simon64Cipher) BlockSize() int {
	return 8
}

func simonScramble32(x uint32) uint32 {
	return (leftRotate32(x, 1) & leftRotate32(x, 8)) ^ leftRotate32(x, 2)
}

// Encrypt encrypts the first block in src into dst.
// Dst and src may point at the same memory. See crypto/cipher.
func (cipher *Simon64Cipher) Encrypt(dst, src []byte) {
	x := littleEndianBytesToUInt32(src[0:4])
	y := littleEndianBytesToUInt32(src[4:8])
	for i := 0; i < cipher.rounds; i += 2 {
		y ^= simonScramble32(x) ^ cipher.k[i]
		x ^= simonScramble32(y) ^ cipher.k[i+1]
	}
	storeLittleEndianUInt32(dst[0:4], x)
	storeLittleEndianUInt32(dst[4:8], y)
}

// Decrypt decrypts the first block in src into dst.
// Dst and src may point at the same memory. See crypto/cipher.
func (cipher *Simon64Cipher) Decrypt(dst, src []byte) {
	x := littleEndianBytesToUInt32(src[0:4])
	y := littleEndianBytesToUInt32(src[4:8])
	for i := cipher.rounds - 1; i >= 0; i -= 2 {
		x ^= simonScramble32(y) ^ cipher.k[i]
		y ^= simonScramble32(x) ^ cipher.k[i-1]
	}
	storeLittleEndianUInt32(dst[0:4], x)
	storeLittleEndianUInt32(dst[4:8], y)
}

// Use NewSimon128 below to expand a Simon128 key. Simon128Cipher
// implements the cipher.Block interface.
type Simon128Cipher struct {
	k      []uint64
	rounds int
}

func littleEndianBytesToUInt64(b []byte) uint64 {
	r := uint64(0)
	for i := uint(0); i < 8; i++ {
		r |= uint64(b[i]) << (8 * i)
	}
	return r
}

func storeLittleEndianUInt64(dst []byte, n uint64) {
	for i := uint(0); i < 8; i++ {
		dst[i] = byte(n >> (8 * i))
	}
}

// NewSimon64 creates and returns a new Simon64Cipher. It accepts
// either a 96-bit key (for Simon64/96) or a 128-bit key (for
// Simon64/128). See the documentation on Simon32 or the test suite
// for our endianness convention.
func NewSimon128(key []byte) *Simon128Cipher {
	cipher := new(Simon128Cipher)
	var keyWords int
	var z uint64

	switch len(key) {
	case 16:
		keyWords = 2
		z = zSeq2
		cipher.rounds = roundsSimon128_128
	case 24:
		keyWords = 3
		z = zSeq3
		cipher.rounds = roundsSimon128_192
	case 32:
		keyWords = 4
		z = zSeq4
		cipher.rounds = roundsSimon128_256
	default:
		panic("NewSimon128() requires a 128-,  192- or 256-bit key")
	}
	cipher.k = make([]uint64, cipher.rounds)
	for i := 0; i < keyWords; i++ {
		cipher.k[keyWords-i-1] = littleEndianBytesToUInt64(key[8*i : 8*i+8])
	}
	for i := keyWords; i < cipher.rounds; i++ {
		tmp := leftRotate64(cipher.k[i-1], 61)
		if keyWords == 4 {
			tmp ^= cipher.k[i-3]
		}
		tmp ^= leftRotate64(tmp, 63)
		lfsrBit := (z >> uint((i-keyWords)%62)) & 1
		cipher.k[i] = ^cipher.k[i-keyWords] ^ tmp ^ uint64(lfsrBit) ^ 3
	}
	return cipher
}

// Simon64 has a 64-bit block length. Note that this is in bytes, not words.
func (cipher *Simon128Cipher) BlockSize() int {
	return 16
}

func simonScramble64(x uint64) uint64 {
	return (leftRotate64(x, 1) & leftRotate64(x, 8)) ^ leftRotate64(x, 2)
}

// Encrypt encrypts the first block in src into dst.
// Dst and src may point at the same memory. See crypto/cipher.
func (cipher *Simon128Cipher) Encrypt(dst, src []byte) {
	x := littleEndianBytesToUInt64(src[0:8])
	y := littleEndianBytesToUInt64(src[8:16])
	for i := 0; i < cipher.rounds; i++ {
		x, y = y^simonScramble64(x)^cipher.k[i], x
	}
	storeLittleEndianUInt64(dst[0:8], x)
	storeLittleEndianUInt64(dst[8:16], y)
}

// Decrypt decrypts the first block in src into dst.
// Dst and src may point at the same memory. See crypto/cipher.
func (cipher *Simon128Cipher) Decrypt(dst, src []byte) {
	x := littleEndianBytesToUInt64(src[0:8])
	y := littleEndianBytesToUInt64(src[8:16])
	for i := cipher.rounds - 1; i >= 0; i-- {
		x, y = y, x^simonScramble64(y)^cipher.k[i]
	}
	storeLittleEndianUInt64(dst[0:8], x)
	storeLittleEndianUInt64(dst[8:16], y)
}
