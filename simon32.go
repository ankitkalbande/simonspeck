package simonspeck

const roundsSimon32_64 = 32

// Use NewSimon32 below to expand a Simon32 key. Simon32Cipher
// implements the cipher.Block interface.
type Simon32Cipher struct {
	k [32]uint16
}

// NewSimon32 creates and returns a new Simon32Cipher. To compare with
// the test vectors in the NSA paper, give the key words in the reverse
// order as they appear in the paper, and as little-endian words. For
// example, the cipher with key "1918 1110 0908 0100" is generated by
// NewSimon32([]byte{0x00, 0x01, 0x08, 0x09, 0x10, 0x11, 0x18, 0x19}).
func NewSimon32(key []byte) *Simon32Cipher {
	cipher := new(Simon32Cipher)

	if len(key) != 8 {
		panic("NewSimon32 requires an 8-byte key")
	}
	for i := 0; i < 4; i++ {
		cipher.k[i] = littleEndianBytesToUInt16(key[2*i : 2*i+2])
	}
	for i, reg := 4, uint(1); i < roundsSimon32_64; i++ {
		tmp := rightRotate16(cipher.k[i-1], 3)
		tmp ^= cipher.k[i-3]
		tmp ^= rightRotate16(tmp, 1)
		cipher.k[i] = ^cipher.k[i-4] ^ tmp ^ uint16(reg&1) ^ 3
		reg = ShiftU(reg)
	}
	return cipher
}

// Simon32 has a 32-bit block length. Note that this is in bytes, not words.
func (cipher *Simon32Cipher) BlockSize() int {
	return 4
}

// simonScramble16 is the only non-affine component of the Simon block cipher.
func simonScramble16(x uint16) uint16 {
	return (leftRotate16(x, 1) & leftRotate16(x, 8)) ^ leftRotate16(x, 2)
}

// Encrypt encrypts the first block in src into dst. Dst and src may
// point at the same memory. See crypto/cipher. This accepts blocks in
// the reverse order as they appear in the original paper and as
// little endian words. See the test suite for an example.
func (cipher *Simon32Cipher) Encrypt(dst, src []byte) {
	if len(src) < 4 || len(dst) < 4 {
		panic("Simon32Cipher.Encrypt() requires at least one block to encipher.")
	}
	y := littleEndianBytesToUInt16(src[0:2])
	x := littleEndianBytesToUInt16(src[2:4])
	for i := 0; i < roundsSimon32_64; i += 2 {
		y ^= simonScramble16(x) ^ cipher.k[i]
		x ^= simonScramble16(y) ^ cipher.k[i+1]
	}
	storeLittleEndianUInt16(dst[0:2], y)
	storeLittleEndianUInt16(dst[2:4], x)
}

// Decrypt decrypts the first block in src into dst.
// Dst and src may point at the same memory. See crypto/cipher.
func (cipher *Simon32Cipher) Decrypt(dst, src []byte) {
	if len(src) < 4 || len(dst) < 4 {
		panic("Simon32Cipher.Encrypt() requires at least one block to decipher.")
	}
	y := littleEndianBytesToUInt16(src[0:2])
	x := littleEndianBytesToUInt16(src[2:4])
	for i := roundsSimon32_64 - 1; i > 0; i -= 2 {
		x ^= simonScramble16(y) ^ cipher.k[i]
		y ^= simonScramble16(x) ^ cipher.k[i-1]
	}
	storeLittleEndianUInt16(dst[0:2], y)
	storeLittleEndianUInt16(dst[2:4], x)
}
