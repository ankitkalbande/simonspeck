// Copyright 2013 Samuel Isaacson. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

// Package simonspeck implements the Simon and Speck families of NSA
// block ciphers. It is a straightforward translation of the
// pseudocode in the paper [1] into golang. THIS IMPLEMENTATION IS NOT
// CRYPTOGRAPHICALLY SECURE. This code correctly encodes the supplied
// test vectors in [1] with the following conventions: words are
// stored with a little-endian representation, and the test vectors
// are reversed (i.e., the plaintext "6565 6877" for Simon32/64 is
// stored as []byte{0x77, 0x68, 0x65, 0x65}. I chose this convention
// since with it, the Simon test vector plaintexts concatenate to the
// phrase "wheeling and circling round like the pillar of dust that
// travellers describe when there is a simoom in t" and the Speck test
// vector plaintexts concatenate to "Literally this means Fat-cutter;
// usage, however, in time made it equivalent to Chief Harpooner. In
// those". Each cipher implements the cipher.Block interface (godoc
// crypto/cipher).
//
// [1]: http://eprint.iacr.org/2013/404
package simonspeck

const (
	zSeq0 = 0xd9c3522fb386a45f
	zSeq1 = 0x56864fb8ad0c9f71
	zSeq2 = 0x7369f885192c0ef5
	zSeq3 = 0xfc2ce51207a635db
	zSeq4 = 0xfdc94c3a046d678b

	bitMask24 = 0x00ffffff
	bitMask48 = 0x0000ffffffffffff
)

// Simon relies on five bit sequences generated by LFSRs. For reference
// I've implemented each as a shift register rather than bit constants.
// ShiftU corresponds to the matrix
// [0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 1 0 0 0 1].
func ShiftU(reg uint) uint {
	s := reg << 1
	if s&32 != 0 {
		s ^= 37
	}
	s ^= reg & 1
	return s
}

// ShiftV corresponds to the matrix
// [0 1 1 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 1 0 0 0 0].
func ShiftV(reg uint) uint {
	s := reg << 1
	if s&32 != 0 {
		s ^= 37
	}
	s ^= (reg & 4) << 2
	return s
}

// ShiftW corresponds to the matrix
// [0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 1 0 0 0 0].
func ShiftW(reg uint) uint {
	s := reg << 1
	if s&32 != 0 {
		s ^= 37
	}
	return s
}

func leftRotate16(n uint16, shift uint) uint16 {
	return (n << shift) | (n >> (16 - shift))
}

func leftRotate24(n uint32, shift uint) uint32 {
	return ((n << shift) & bitMask24) | (n >> (24 - shift))
}

func leftRotate32(n uint32, shift uint) uint32 {
	return (n << shift) | (n >> (32 - shift))
}

func leftRotate48(n uint64, shift uint) uint64 {
	return ((n << shift) & bitMask48) | (n >> (48 - shift))
}

func leftRotate64(n uint64, shift uint) uint64 {
	return (n << shift) | (n >> (64 - shift))
}

func rightRotate16(n uint16, shift uint) uint16 {
	return leftRotate16(n, 16-shift)
}

func rightRotate24(n uint32, shift uint) uint32 {
	return leftRotate24(n, 24-shift)
}

func rightRotate32(n uint32, shift uint) uint32 {
	return leftRotate32(n, 32-shift)
}

func rightRotate48(n uint64, shift uint) uint64 {
	return leftRotate48(n, 48-shift)
}

func rightRotate64(n uint64, shift uint) uint64 {
	return leftRotate64(n, 64-shift)
}

func littleEndianBytesToUInt16(b []byte) uint16 {
	return uint16(b[0]) | (uint16(b[1]) << 8)
}

func littleEndianBytesToUInt24(b []byte) uint32 {
	return uint32(b[0]) | (uint32(b[1]) << 8) | (uint32(b[2]) << 16)
}

func littleEndianBytesToUInt32(b []byte) uint32 {
	return uint32(b[0]) | (uint32(b[1]) << 8) | (uint32(b[2]) << 16) | (uint32(b[3]) << 24)
}

func littleEndianBytesToUInt48(b []byte) uint64 {
	r := uint64(0)
	for i := uint(0); i < 6; i++ {
		r |= uint64(b[i]) << (8 * i)
	}
	return r
}

func littleEndianBytesToUInt64(b []byte) uint64 {
	r := uint64(0)
	for i := uint(0); i < 8; i++ {
		r |= uint64(b[i]) << (8 * i)
	}
	return r
}

func storeLittleEndianUInt16(dst []byte, n uint16) {
	dst[0] = byte(n)
	dst[1] = byte(n >> 8)
}

func storeLittleEndianUInt24(dst []byte, n uint32) {
	dst[0] = byte(n)
	dst[1] = byte(n >> 8)
	dst[2] = byte(n >> 16)
}

func storeLittleEndianUInt32(dst []byte, n uint32) {
	dst[0] = byte(n)
	dst[1] = byte(n >> 8)
	dst[2] = byte(n >> 16)
	dst[3] = byte(n >> 24)
}

func storeLittleEndianUInt48(dst []byte, n uint64) {
	for i := uint(0); i < 6; i++ {
		dst[i] = byte(n >> (8 * i))
	}
}

func storeLittleEndianUInt64(dst []byte, n uint64) {
	for i := uint(0); i < 8; i++ {
		dst[i] = byte(n >> (8 * i))
	}
}
